From ea242bf3e17ec4a66ba327bb88a901536f5f4065 Mon Sep 17 00:00:00 2001
From: githubgrasp <peter.grassl@glasgow.ac.uk>
Date: Mon, 26 Oct 2020 23:44:40 +0000
Subject: [PATCH 1/4] adjust number of steps in nldeidynamic

---
 doc/oofemInput/oofemInput.tex           |  9 +++++----
 src/oofemlib/engngm.C                   |  3 +--
 src/sm/EngineeringModels/nldeidynamic.C | 23 +++++++++++++++++------
 src/sm/EngineeringModels/nldeidynamic.h |  4 +++-
 tests/sm/nldeidynamic1.in               | 23 +++++++++++++++++++++++
 5 files changed, 49 insertions(+), 13 deletions(-)
 create mode 100644 tests/sm/nldeidynamic1.in

diff --git a/doc/oofemInput/oofemInput.tex b/doc/oofemInput/oofemInput.tex
index f411bf51d..8102ada84 100644
--- a/doc/oofemInput/oofemInput.tex
+++ b/doc/oofemInput/oofemInput.tex
@@ -571,10 +571,11 @@ \subsection{NlDEIDynamic}
 The central difference method with diagonal mass matrix is used,
 damping matrix is assumed to be proportional to mass matrix, $\mbf{C}
 = \mathrm{dumpcoef} * \mbf{M}$, where
-$\mbf{M}$ is diagonal mass matrix. \param{deltaT} is time step length used for
-integration, which may be reduced by program in order to satisfy
-solution stability conditions. Parameter \param{nsteps} specifies
-how many time steps will be analyzed.
+$\mbf{M}$ is diagonal mass matrix.
+Parameter \param{nsteps} specifies how many time steps will be analyzed.
+\param{deltaT} is time step length used for integration, which may be reduced by program in order to satisfy solution stability conditions.
+Parameter \param{reduct} is a scaling factor (smaller than 1), which is multiplied with the determined step length adjusted by the program.
+If \param{deltaT} is reduced internally, then \param{nsteps} is adjusted so that the total analysis time remains the same.
 
 The parallel version has the following additional syntax:\\ \\
 \begin{record}
diff --git a/src/oofemlib/engngm.C b/src/oofemlib/engngm.C
index b0cbf23ee..819ddb728 100644
--- a/src/oofemlib/engngm.C
+++ b/src/oofemlib/engngm.C
@@ -503,8 +503,7 @@ EngngModel :: solveYourself()
         // update state according to new meta step
         this->initMetaStepAttributes(activeMStep);
 
-        int nTimeSteps = activeMStep->giveNumberOfSteps();
-        for ( int jstep = sjstep; jstep <= nTimeSteps; jstep++ ) { //loop over time steps
+	for ( int jstep = sjstep; jstep <= activeMStep->giveNumberOfSteps(); jstep++ ) { //loop over time steps
             this->timer.startTimer(EngngModelTimer :: EMTT_SolutionStepTimer);
             this->timer.initTimer(EngngModelTimer :: EMTT_NetComputationalStepTimer);
 
diff --git a/src/sm/EngineeringModels/nldeidynamic.C b/src/sm/EngineeringModels/nldeidynamic.C
index 26a8ec7b0..f604293b7 100644
--- a/src/sm/EngineeringModels/nldeidynamic.C
+++ b/src/sm/EngineeringModels/nldeidynamic.C
@@ -86,6 +86,9 @@ NlDEIDynamic :: initializeFrom(InputRecord &ir)
     IR_GIVE_FIELD(ir, dumpingCoef, _IFT_NlDEIDynamic_dumpcoef); // C = dumpingCoef * M
     IR_GIVE_FIELD(ir, deltaT, _IFT_NlDEIDynamic_deltat);
 
+    reductionFactor = 1.;
+    IR_GIVE_OPTIONAL_FIELD(ir, reductionFactor, _IFT_NlDEIDynamic_reduct);
+ 
     drFlag = 0;
     IR_GIVE_OPTIONAL_FIELD(ir, drFlag, _IFT_NlDEIDynamic_drflag);
     if ( drFlag ) {
@@ -287,12 +290,20 @@ void NlDEIDynamic :: solveYourselfAt(TimeStep *tStep)
         //
 
         // Try to determine the best deltaT,
-        double maxDt = 2.0 / sqrt(maxOm);
-        if ( deltaT > maxDt ) {
-            // Print reduced time step increment and minimum period Tmin
-            OOFEM_LOG_RELEVANT("deltaT reduced to %e, Tmin is %e\n", maxDt, maxDt * M_PI);
-            deltaT = maxDt;
-            tStep->setTimeIncrement(deltaT);
+	double maxDt = reductionFactor * 2.0 / sqrt(maxOm);
+        int newNumberOfSteps = this->numberOfSteps;
+        double newDeltaT = 0;
+
+	if ( deltaT > maxDt ) {
+	  //Scale number of steps based on reduced time step        
+	  newDeltaT = maxDt;
+	  newNumberOfSteps = floor(numberOfSteps*deltaT/newDeltaT);
+	  this->giveMetaStep(1)->setNumberOfSteps(newNumberOfSteps);
+	  this->deltaT = newDeltaT;
+	  tStep->setTimeIncrement(deltaT);
+	  
+	  // Print reduced time step increment and minimum period Tmin
+	  OOFEM_LOG_RELEVANT("deltaT reduced to %e, Tmin is %e, nsteps is %d\n", this->deltaT, maxDt * M_PI, newNumberOfSteps);	  
         }
 
         for ( int j = 1; j <= neq; j++ ) {
diff --git a/src/sm/EngineeringModels/nldeidynamic.h b/src/sm/EngineeringModels/nldeidynamic.h
index c99f9785e..4289addd1 100644
--- a/src/sm/EngineeringModels/nldeidynamic.h
+++ b/src/sm/EngineeringModels/nldeidynamic.h
@@ -54,6 +54,7 @@
 #define _IFT_NlDEIDynamic_tau "tau"
 #define _IFT_NlDEIDynamic_py "py"
 #define _IFT_NlDEIDynamic_nonlocalext "nonlocalext"
+#define _IFT_NlDEIDynamic_reduct "reduct"
 //@}
 
 namespace oofem {
@@ -106,7 +107,8 @@ class NlDEIDynamic : public StructuralEngngModel
     double deltaT;
     /// Flag indicating the need for initialization.
     int initFlag;
-
+    /// Optional reduction factor for time step deltaT
+    double reductionFactor;
     // dynamic relaxation specific vars
     /// Flag indicating whether dynamic relaxation takes place.
     int drFlag;
diff --git a/tests/sm/nldeidynamic1.in b/tests/sm/nldeidynamic1.in
new file mode 100644
index 000000000..f19e6b35e
--- /dev/null
+++ b/tests/sm/nldeidynamic1.in
@@ -0,0 +1,23 @@
+nldeidynamic1.out
+truss to test nldeidynamic
+NlDEIDynamic nsteps 1 nmodules 1 contextOutputStep 1000000 dumpcoef 0. deltat 0.0001 reduct 0.8 profileopt 1
+errorcheck
+domain 3d
+OutputManager tstep_all dofman_output { 1 3 }
+ndofman 3 nelem 2 ncrosssect 1 nmat 1 nbc 2 nic 0 nltf 2
+node 1 coords 3 5.000000e-02 5.000000e-02 0.000000e+00 bc 3 1 1 1
+node 2 coords 3 5.000000e-02 5.000000e-02 2.000000e-02
+node 3 coords 3 5.000000e-02 5.000000e-02 4.000000e-02 bc 3 1 1 2
+truss3d 1 nodes 2 1 2 crossSect 1 mat 1
+truss3d 2 nodes 2 2 3 crossSect 1 mat 1
+SimpleCS 1 area 2.0106e-4 
+isole 1 d 7600 n 0.2 e 200.00e9 talpha 0.
+BoundaryCondition  1 loadTimeFunction 1 prescribedvalue 0.0 
+BoundaryCondition  2 loadTimeFunction 2 prescribedvalue 0.00015 
+ConstantFunction 1 f(t) 1.0  
+PiecewiseLinFunction 2 t 2 0. 0.1 f(t) 2 0.0 1.0
+
+#%BEGIN_CHECK% 
+#NODE tStep 22 number 3 dof 3 unknown d value 6.61634340e-09 tolerance 1.e-12
+#REACTION tStep 22 number 1 dof 3 value 1.3303e+01 tolerance 1.e-3
+#%END_CHECK%
\ No newline at end of file

From f7e19ffc32b7b57df2e56d0b022fcbedfc5b609f Mon Sep 17 00:00:00 2001
From: githubgrasp <peter.grassl@glasgow.ac.uk>
Date: Mon, 2 Nov 2020 23:17:20 +0000
Subject: [PATCH 2/4] extend misesmat to multilinear hardening for 1D

---
 doc/matlibmanual/matlibmanual.tex |  11 +-
 src/sm/Materials/misesmat.C       | 265 ++++++++++++++++++++----------
 src/sm/Materials/misesmat.h       |  24 ++-
 tests/sm/Mises02.in               |  29 ++++
 4 files changed, 230 insertions(+), 99 deletions(-)
 create mode 100644 tests/sm/Mises02.in

diff --git a/doc/matlibmanual/matlibmanual.tex b/doc/matlibmanual/matlibmanual.tex
index 443479b50..0e562546d 100644
--- a/doc/matlibmanual/matlibmanual.tex
+++ b/doc/matlibmanual/matlibmanual.tex
@@ -742,7 +742,7 @@ \subsubsection{Mises plasticity model with isotropic damage - MisesMat}
 \begin{equation}\label{VMcumPlasStrain}
 \dot{\kappa} = \| \epspd \|,
 \end{equation}
-the linear hardening law
+the linear hardening law (for \param{htype} = 0)
 \begin{equation}\label{VMlinearHardeningLaw}
 \sigma_Y(\kappa) = \sigma_0 + H\kappa,
 \end{equation}
@@ -778,13 +778,16 @@ \subsubsection{Mises plasticity model with isotropic damage - MisesMat}
 Description & Mises plasticity model with isotropic hardening\\
 \hline
 Record Format & \descitem{MisesMat}  \elemparam{}{in}
-\elemparam{d}{rn} \elemparam{E}{rn} \elemparam{n}{rn} \elemparam{sig0}{rn} \elemparam{H}{rn} \elemparam{omega\_crit}{rn}\elemparam{a}{rn}\\
+\elemparam{d}{rn} \elemparam{E}{rn} \elemparam{n}{rn} \elemparam{sig0}{rn} \elemparam{H}{rn} \optelemparam{htype}{in} \optelemparam{h\_eps}{ra} \optelemparam{h(eps)}{ra} \elemparam{omega\_crit}{rn}\elemparam{a}{rn}\\
 Parameters &- \param{} material number\\
 &- \param{d} material density\\
 &- \param{E} Young's modulus\\
 &- \param{n} Poisson's ratio\\
-&- \param{sig0} initial yield stress in uniaxial tension (compression)\\
-&- \param{H} hardening modulus (can be negative in the case of plastic softening)\\
+&- \param{sig0} initial yield stress in uniaxial tension (compression) (Required if htype = 0, which is default)\\
+&- \param{H} hardening modulus (can be negative in the case of plastic softening) (Required if htype = 0, which is default)\\
+&- \param{htype} hardening type (Optional parameter. Default = 0)\\
+&- \param{h\_eps} array of plastic strains (Required if htype = 1)\\
+&- \param{h(eps)} array of yield stresses (Required if htype = 1)\\
 &- \param{omega\_crit} critical damage in damage law (\ref{damagelawmp})\\
 &- \param{a} exponent in damage law (\ref{damagelawmp})\\
 Supported modes& 1dMat, PlaneStrain, 3dMat, 3dMatF\\
diff --git a/src/sm/Materials/misesmat.C b/src/sm/Materials/misesmat.C
index 7fe75815c..35873ced9 100644
--- a/src/sm/Materials/misesmat.C
+++ b/src/sm/Materials/misesmat.C
@@ -51,24 +51,42 @@ namespace oofem {
 REGISTER_Material(MisesMat);
 
 
-MisesMat :: MisesMat(int n, Domain *d) : StructuralMaterial(n, d),
+MisesMat::MisesMat(int n, Domain *d) : StructuralMaterial(n, d),
     linearElasticMaterial(n, d)
 {}
 
 
 void
-MisesMat :: initializeFrom(InputRecord &ir)
+MisesMat::initializeFrom(InputRecord &ir)
 {
-    StructuralMaterial :: initializeFrom(ir);
+    StructuralMaterial::initializeFrom(ir);
     linearElasticMaterial.initializeFrom(ir); // takes care of elastic constants
 
     G = linearElasticMaterial.giveShearModulus();
     K = linearElasticMaterial.giveBulkModulus();
 
-    IR_GIVE_FIELD(ir, sig0, _IFT_MisesMat_sig0); // uniaxial yield stress
 
-    H = 0.;
-    IR_GIVE_OPTIONAL_FIELD(ir, H, _IFT_MisesMat_h); // hardening modulus
+    hType = 0;
+    IR_GIVE_OPTIONAL_FIELD(ir, hType, _IFT_MisesMat_htype); //hardening type
+
+    if ( hType == 0 ) {
+        IR_GIVE_FIELD(ir, sig0, _IFT_MisesMat_sig0); // uniaxial yield stress
+        H = 0.;
+        IR_GIVE_OPTIONAL_FIELD(ir, H, _IFT_MisesMat_h); // hardening modulus
+    } else if ( hType == 1 ) {     //user defined hardening function
+        IR_GIVE_FIELD(ir, h_eps, _IFT_MisesMat_h_eps);
+        IR_GIVE_FIELD(ir, h_function_eps, _IFT_MisesMat_h_function_eps);
+
+        if ( h_eps.at(1) != 0. ) {
+            throw ValueInputException(ir, _IFT_MisesMat_h_eps, "The first entry in h_eps must be 0.");
+        }
+
+        if ( h_eps.giveSize() != h_function_eps.giveSize() ) {
+            throw ValueInputException(ir, _IFT_MisesMat_h_function_eps, "the size of 'h_eps' and 'h(eps)' must be the same");
+        }
+    } else {
+        throw ValueInputException(ir, _IFT_MisesMat_htype, "Unknown htype. Should be either 0 or 1.\n");
+    }
 
     omega_crit = 0;
     IR_GIVE_OPTIONAL_FIELD(ir, omega_crit, _IFT_MisesMat_omega_crit); // critical damage
@@ -82,15 +100,15 @@ MisesMat :: initializeFrom(InputRecord &ir)
 
 // creates a new material status  corresponding to this class
 MaterialStatus *
-MisesMat :: CreateStatus(GaussPoint *gp) const
+MisesMat::CreateStatus(GaussPoint *gp) const
 {
     return new MisesMatStatus(gp);
 }
 
-FloatArrayF<1>
-MisesMat :: giveRealStressVector_1d(const FloatArrayF<1> &totalStrain,
-                                    GaussPoint *gp,
-                                    TimeStep *tStep) const
+FloatArrayF< 1 >
+MisesMat::giveRealStressVector_1d(const FloatArrayF< 1 > &totalStrain,
+                                  GaussPoint *gp,
+                                  TimeStep *tStep) const
 {
     /// @note: One should obtain the same answer using the iterations in the default implementation (this is verified for this model).
 #if 1
@@ -101,36 +119,38 @@ MisesMat :: giveRealStressVector_1d(const FloatArrayF<1> &totalStrain,
     this->giveStressDependentPartOfStrainVector(strainR, gp, totalStrain, tStep, VM_Total);
     this->performPlasticityReturn(strainR, gp, tStep);
     double omega = computeDamage(gp, tStep);
-    FloatArrayF<6> stress = status->giveTempEffectiveStress() * (1 - omega);
+    FloatArrayF< 6 >stress = status->giveTempEffectiveStress() * ( 1 - omega );
 
     // Compute the other components of the strain:
     double E = linearElasticMaterial.give('E', gp), nu = linearElasticMaterial.give('n', gp);
 
     auto strain = status->getTempPlasticStrain();
     strain [ 0 ] = totalStrain [ 0 ];
-    strain [ 1 ] -= nu / E *status->giveTempEffectiveStress() [ 0 ];
-    strain [ 2 ] -= nu / E *status->giveTempEffectiveStress() [ 0 ];
+    strain [ 1 ] -= nu / E * status->giveTempEffectiveStress() [ 0 ];
+    strain [ 2 ] -= nu / E * status->giveTempEffectiveStress() [ 0 ];
 
     status->letTempStrainVectorBe(strain);
     status->setTempDamage(omega);
     status->letTempStressVectorBe(stress);
-    return stress[{0}];
+    return stress [ { 0 } ];
+
 #else
-    return StructuralMaterial :: giveRealStressVector_1d(totalStrain, gp, tStep);
+    return StructuralMaterial::giveRealStressVector_1d(totalStrain, gp, tStep);
+
 #endif
 }
 
 
-FloatArrayF<3>
-MisesMat :: giveRealStressVector_PlaneStress(const FloatArrayF<3> &totalStrain,
-                                             GaussPoint *gp, TimeStep *tStep) const
+FloatArrayF< 3 >
+MisesMat::giveRealStressVector_PlaneStress(const FloatArrayF< 3 > &totalStrain,
+                                           GaussPoint *gp, TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     // initialization
-    const_cast<MisesMat*>(this)->initTempStatus(gp);
+    const_cast< MisesMat * >( this )->initTempStatus(gp);
     this->performPlasticityReturn_PlaneStress(totalStrain, gp, tStep);
     double omega = computeDamage(gp, tStep);
-    FloatArrayF<3> stress = status->giveTempEffectiveStress() * (1 - omega);
+    FloatArrayF< 3 >stress = status->giveTempEffectiveStress() * ( 1 - omega );
     status->setTempDamage(omega);
     status->letTempStrainVectorBe(totalStrain);
     status->letTempStressVectorBe(stress);
@@ -138,9 +158,9 @@ MisesMat :: giveRealStressVector_PlaneStress(const FloatArrayF<3> &totalStrain,
 }
 
 
-FloatArrayF<6>
-MisesMat :: giveRealStressVector_3d(const FloatArrayF<6> &strain, GaussPoint *gp,
-                                    TimeStep *tStep) const
+FloatArrayF< 6 >
+MisesMat::giveRealStressVector_3d(const FloatArrayF< 6 > &strain, GaussPoint *gp,
+                                  TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     // subtract stress independent part
@@ -149,7 +169,7 @@ MisesMat :: giveRealStressVector_3d(const FloatArrayF<6> &strain, GaussPoint *gp
 
     this->performPlasticityReturn(strainR, gp, tStep);
     double omega = computeDamage(gp, tStep);
-    auto stress = status->giveTempEffectiveStress() * (1 - omega);
+    auto stress = status->giveTempEffectiveStress() * ( 1 - omega );
     status->setTempDamage(omega);
     status->letTempStrainVectorBe(strain);
     status->letTempStressVectorBe(stress);
@@ -158,7 +178,7 @@ MisesMat :: giveRealStressVector_3d(const FloatArrayF<6> &strain, GaussPoint *gp
 
 
 void
-MisesMat :: performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *gp, TimeStep *tStep) const
+MisesMat::performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *gp, TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     double kappa;
@@ -168,23 +188,35 @@ MisesMat :: performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *g
     plStrain = status->givePlasticStrain();
     kappa = status->giveCumulativePlasticStrain();
 
+    double dKappa = 0.;
     // === radial return algorithm ===
     if ( totalStrain.giveSize() == 1 ) {
         double E = linearElasticMaterial.give('E', gp);
         /*trial stress*/
         fullStress.resize(6);
         fullStress.at(1) = E * ( totalStrain.at(1) - plStrain.at(1) );
-        double trialS = fabs( fullStress.at(1) );
+        double trialS = fabs(fullStress.at(1) );
         /*yield function*/
-        double yieldValue = trialS - ( this->give('s', gp, tStep) + H * kappa );
+        double yieldValue = trialS - computeYieldStress(kappa, gp, tStep);
         // === radial return algorithm ===
         if ( yieldValue > 0 ) {
-            double dKappa = yieldValue / ( H + E );
+            if ( hType == 0 ) {
+                dKappa = yieldValue / ( computeYieldStressPrime(kappa) + E );
+            }
+            if ( hType == 1 ) {
+                dKappa += yieldValue / ( computeYieldStressPrime(kappa) + E );
+                yieldValue = trialS - checkYieldStress(dKappa, kappa, gp, tStep);
+                yieldValue -= E * dKappa;
+                if ( yieldValue > 1.e-10 ) {
+                    dKappa += yieldValue / ( computeYieldStressPrime(kappa + dKappa) + E );
+                }
+            }
+
             kappa += dKappa;
-            plStrain.at(1) += dKappa * signum( fullStress.at(1) );
-            plStrain.at(2) -= 0.5 *dKappa *signum( fullStress.at(1) );
-            plStrain.at(3) -= 0.5 *dKappa *signum( fullStress.at(1) );
-            fullStress.at(1) -= dKappa * E * signum( fullStress.at(1) );
+            plStrain.at(1) += dKappa * signum(fullStress.at(1) );
+            plStrain.at(2) -= 0.5 * dKappa * signum(fullStress.at(1) );
+            plStrain.at(3) -= 0.5 * dKappa * signum(fullStress.at(1) );
+            fullStress.at(1) -= dKappa * E * signum(fullStress.at(1) );
         }
     } else {
         // elastic predictor
@@ -204,10 +236,10 @@ MisesMat :: performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *g
         status->setTrialStressVol(trialStressVol);
         // check the yield condition at the trial state
         double trialS = computeStressNorm(trialStressDev);
-        double yieldValue = sqrt(3. / 2.) * trialS - ( this->give('s', gp, tStep) + H * kappa );
+        double yieldValue = sqrt(3. / 2.) * trialS - ( computeYieldStress(kappa, gp, tStep) );
         if ( yieldValue > 0. ) {
             // increment of cumulative plastic strain
-            double dKappa = yieldValue / ( H + 3. * G );
+            double dKappa = yieldValue / ( computeYieldStressPrime(kappa) + 3. * G );
             kappa += dKappa;
             // the following line is equivalent to multiplication by scaling matrix P
             FloatArray dPlStrain = applyDeviatoricElasticCompliance(trialStressDev, 0.5);
@@ -231,7 +263,7 @@ MisesMat :: performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *g
 }
 
 void
-MisesMat :: performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrain, GaussPoint *gp, TimeStep *tStep) const
+MisesMat::performPlasticityReturn_PlaneStress(const FloatArrayF< 3 > &totalStrain, GaussPoint *gp, TimeStep *tStep) const
 {
     double E = linearElasticMaterial.give('E', gp);
     double nu = linearElasticMaterial.give('n', gp);
@@ -241,7 +273,7 @@ MisesMat :: performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrai
     FloatArray fullStress;
     // get the initial plastic strain and initial kappa from the status
     plStrain = status->givePlasticStrain();
-    StructuralMaterial :: giveReducedSymVectorForm(redPlStrain, plStrain, _PlaneStress);
+    StructuralMaterial::giveReducedSymVectorForm(redPlStrain, plStrain, _PlaneStress);
     kappa = status->giveCumulativePlasticStrain();
     FloatMatrix Ps, Pe;
 
@@ -287,9 +319,9 @@ MisesMat :: performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrai
         double denom1 = 1.;
         double denom2 = 1.;
         while ( true ) {
-            double HiP = this->computeYieldStressPrime( kappa + dKappa * sqrt(2. * xi / 3.) );
+            double HiP = this->computeYieldStressPrime(kappa + dKappa * sqrt(2. * xi / 3.) );
             double dXi = -a1 * E / ( 1. - nu ) / 9. / denom1 / denom1 / denom1 - 2. * G * ( a2 + 4. * a3 ) / denom2 / denom2 / denom2;
-            double Hbar = 2. *sigmaY *HiP *sqrt(2. / 3.) * ( sqrt(xi) + dKappa * dXi / ( 2. * sqrt(xi) ) );
+            double Hbar = 2. * sigmaY * HiP * sqrt(2. / 3.) * ( sqrt(xi) + dKappa * dXi / ( 2. * sqrt(xi) ) );
             double df = 0.5 * dXi - 1. / 3. * Hbar;
             dKappa -= f / df;
             // Compute new residual (yield function value)
@@ -327,7 +359,7 @@ MisesMat :: performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrai
         redPlStrain.at(1) = totalStrain.at(1) - ( 2. / 3. * fullStress.at(1) - 1. / 3. * fullStress.at(2) ) / 2. / G - elStrainVol / 3;
         redPlStrain.at(2) = totalStrain.at(2) - ( 2. / 3. * fullStress.at(2) - 1. / 3. * fullStress.at(1) ) / 2. / G  - elStrainVol / 3;
         redPlStrain.at(3) = totalStrain.at(3) - fullStress.at(3) / G;
-        StructuralMaterial :: giveFullSymVectorForm(plStrain, redPlStrain, _PlaneStress);
+        StructuralMaterial::giveFullSymVectorForm(plStrain, redPlStrain, _PlaneStress);
         // incompresibility condition
         plStrain.at(3) = -( plStrain.at(1) + plStrain.at(2) );
         // store the plastic strain and cumulative plastic strain
@@ -344,21 +376,76 @@ MisesMat :: performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrai
 
 
 double
-MisesMat :: computeYieldStress(double kappa, GaussPoint *gp, TimeStep *tStep) const
+MisesMat::checkYieldStress(double &dKappa, double kappa, GaussPoint *gp, TimeStep *tStep) const
+{
+    double yieldStress = 0.;
+    if ( hType == 1 ) {
+        if ( kappa + dKappa > h_eps.at(h_eps.giveSize() ) ) {
+            OOFEM_ERROR("kappa outside range of specified hardening law/n");
+        }
+
+        for ( int i = 1; i < h_eps.giveSize(); i++ ) {
+            if ( kappa + dKappa >= h_eps.at(i) && kappa + dKappa < h_eps.at(i + 1) && kappa < h_eps.at(i) ) {
+                yieldStress = h_function_eps.at(i);
+                dKappa = h_eps.at(i) - kappa;
+                return yieldStress;
+            } else if ( kappa >= h_eps.at(i) && kappa < h_eps.at(i + 1) && kappa + dKappa >= h_eps.at(i) && kappa + dKappa < h_eps.at(i + 1) ) {
+                yieldStress = h_function_eps.at(i) + ( kappa + dKappa - h_eps.at(i) ) / ( h_eps.at(i + 1) - h_eps.at(i) ) * ( h_function_eps.at(i + 1) - h_function_eps.at(i) );
+                return yieldStress;
+            }
+        }
+    } else {
+        OOFEM_ERROR("MisesMat: Should not check yield stress for htype = 0\n");
+    }
+}
+
+double
+MisesMat::computeYieldStress(double kappa, GaussPoint *gp, TimeStep *tStep) const
 {
-    return this->give('s', gp, tStep) + this->H * kappa; // + ( this->sigInf - this->sig0 ) * (1. - exp(-expD*kappa));
+    double yieldStress = 0.;
+    if ( hType == 0 ) {
+        return this->give('s', gp, tStep) + this->H * kappa; // + ( this->sigInf - this->sig0 ) * (1. - exp(-expD*kappa));
+    } else {
+        if ( kappa > h_eps.at(h_eps.giveSize() ) ) {
+            OOFEM_ERROR("kappa outside range of specified hardening law/n");
+        }
+
+        for ( int i = 1; i < h_eps.giveSize(); i++ ) {
+            if ( kappa >= h_eps.at(i) && kappa < h_eps.at(i + 1) ) {
+                yieldStress = h_function_eps.at(i) + ( kappa - h_eps.at(i) ) / ( h_eps.at(i + 1) - h_eps.at(i) ) * ( h_function_eps.at(i + 1) - h_function_eps.at(i) );
+                return yieldStress;
+            }
+        }
+    }
 }
 
+
 double
-MisesMat :: computeYieldStressPrime(double kappa) const
+MisesMat::computeYieldStressPrime(double kappa) const
 {
-    return this->H; // + ( this->sigInf - this->sig0 ) * expD * exp(-expD*kappa);
+    double yieldStressPrime;
+    if ( hType == 0 ) {
+        yieldStressPrime = this->H;
+        return yieldStressPrime;
+    } else {
+        if ( kappa > h_eps.at(h_eps.giveSize() ) ) {
+            OOFEM_ERROR("kappa outside range of specified hardening law/n");
+        }
+
+
+        for ( int i = 1; i < h_eps.giveSize(); i++ ) {
+            if ( kappa >= h_eps.at(i) && kappa < h_eps.at(i + 1) ) {
+                yieldStressPrime = ( h_function_eps.at(i + 1) - h_function_eps.at(i) ) / ( h_eps.at(i + 1) - h_eps.at(i) );
+                return yieldStressPrime;
+            }
+        }
+    }
 }
 
 
 
 double
-MisesMat :: computeDamageParam(double tempKappa) const
+MisesMat::computeDamageParam(double tempKappa) const
 {
     if ( tempKappa > 0. ) {
         return omega_crit * ( 1.0 - exp(-a * tempKappa) );
@@ -368,7 +455,7 @@ MisesMat :: computeDamageParam(double tempKappa) const
 }
 
 double
-MisesMat :: computeDamageParamPrime(double tempKappa) const
+MisesMat::computeDamageParamPrime(double tempKappa) const
 {
     if ( tempKappa >= 0. ) {
         return omega_crit * a * exp(-a * tempKappa);
@@ -379,7 +466,7 @@ MisesMat :: computeDamageParamPrime(double tempKappa) const
 
 
 double
-MisesMat :: computeDamage(GaussPoint *gp,  TimeStep *tStep) const
+MisesMat::computeDamage(GaussPoint *gp,  TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     double dam = status->giveDamage();
@@ -393,7 +480,7 @@ MisesMat :: computeDamage(GaussPoint *gp,  TimeStep *tStep) const
 }
 
 
-double MisesMat :: computeCumPlastStrain(GaussPoint *gp, TimeStep *tStep) const
+double MisesMat::computeCumPlastStrain(GaussPoint *gp, TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     return status->giveTempCumulativePlasticStrain();
@@ -402,10 +489,10 @@ double MisesMat :: computeCumPlastStrain(GaussPoint *gp, TimeStep *tStep) const
 
 
 // returns the consistent (algorithmic) tangent stiffness matrix
-FloatMatrixF<6,6>
-MisesMat :: give3dMaterialStiffnessMatrix(MatResponseMode mode,
-                                          GaussPoint *gp,
-                                          TimeStep *tStep) const
+FloatMatrixF< 6, 6 >
+MisesMat::give3dMaterialStiffnessMatrix(MatResponseMode mode,
+                                        GaussPoint *gp,
+                                        TimeStep *tStep) const
 {
     // start from the elastic stiffness
     auto d = this->linearElasticMaterial.give3dMaterialStiffnessMatrix(mode, gp, tStep);
@@ -426,16 +513,16 @@ MisesMat :: give3dMaterialStiffnessMatrix(MatResponseMode mode,
     // === plastic loading ===
 
     // yield stress at the beginning of the step
-    double sigmaY = this->give('s', gp, tStep) + H * kappa;
+    double sigmaY = computeYieldStress(kappa, gp, tStep);
 
     // trial deviatoric stress and its norm
-    const FloatArrayF<6> trialStressDev = status->giveTrialStressDev();
+    const FloatArrayF< 6 >trialStressDev = status->giveTrialStressDev();
     //double trialStressVol = status->giveTrialStressVol();
     double trialS = computeStressNorm(trialStressDev);
 
     // one correction term
     double factor = -2. * sqrt(6.) * G * G / trialS;
-    double factor1 = factor * sigmaY / ( ( H + 3. * G ) * trialS * trialS );
+    double factor1 = factor * sigmaY / ( ( computeYieldStressPrime(kappa) + 3. * G ) * trialS * trialS );
     d += factor1 * dyad(trialStressDev, trialStressDev);
 
     // another correction term
@@ -446,23 +533,23 @@ MisesMat :: give3dMaterialStiffnessMatrix(MatResponseMode mode,
     //    double omega = computeDamageParam(tempKappa);
     double omega = status->giveTempDamage();
     d *= 1. - omega;
-    const FloatArrayF<6> effStress = status->giveTempEffectiveStress();
+    const FloatArrayF< 6 >effStress = status->giveTempEffectiveStress();
     double omegaPrime = computeDamageParamPrime(tempKappa);
-    double scalar = -omegaPrime *sqrt(6.) * G / ( 3. * G + H ) / trialS;
+    double scalar = -omegaPrime *sqrt(6.) * G / ( 3. * G + computeYieldStressPrime(kappa) ) / trialS;
     d += scalar * dyad(effStress, trialStressDev);
     return d;
 }
 
 
-FloatMatrixF<3,3>
-MisesMat :: givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, TimeStep *tStep) const
+FloatMatrixF< 3, 3 >
+MisesMat::givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, TimeStep *tStep) const
 {
     auto status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     // start from the elastic stiffness
     auto d = linearElasticMaterial.givePlaneStressStiffMtrx(mmode, gp, tStep);
     if ( mmode != TangentStiffness ) {
         double omega = status->giveTempDamage();
-        return d * (1. - omega);
+        return d * ( 1. - omega );
     }
 
     double kappa = status->giveCumulativePlasticStrain();
@@ -475,7 +562,7 @@ MisesMat :: givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, Time
     // Compute elastoplastic consistent tangent (Box 9.6)
     FloatArray stress, fullStress;
     fullStress = status->giveTempStressVector();
-    StructuralMaterial :: giveReducedSymVectorForm(stress, fullStress, _PlaneStress);
+    StructuralMaterial::giveReducedSymVectorForm(stress, fullStress, _PlaneStress);
     // Compute xi
     double xi = 2. / 3. * ( stress.at(1) * stress.at(1) + stress.at(2) * stress.at(2) - stress.at(1) * stress.at(2) ) + 2. * stress.at(3) * stress.at(3);
     // compute dGamma
@@ -510,22 +597,22 @@ MisesMat :: givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, Time
     correction.beDyadicProductOf(n, n);
     correction.times(alpha);
 
-    FloatMatrixF<3,3> answer;
+    FloatMatrixF< 3, 3 >answer;
     answer.at(1, 1) = 0.5 * ( Es1 + Es2 );
     answer.at(2, 2) = answer.at(1, 1);
     answer.at(1, 2) = 0.5 * ( Es1 - Es2 );
     answer.at(2, 1) = answer.at(1, 2);
     answer.at(3, 3) = Es3;
-    answer -= FloatMatrixF<3,3>(correction);
+    answer -= FloatMatrixF< 3, 3 >(correction);
     //@todo: add damage part of the stiffness
     return answer;
 }
 
 
-FloatMatrixF<1,1>
-MisesMat :: give1dStressStiffMtrx(MatResponseMode mode,
-                                  GaussPoint *gp,
-                                  TimeStep *tStep) const
+FloatMatrixF< 1, 1 >
+MisesMat::give1dStressStiffMtrx(MatResponseMode mode,
+                                GaussPoint *gp,
+                                TimeStep *tStep) const
 {
     MisesMatStatus *status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     double kappa = status->giveCumulativePlasticStrain();
@@ -539,20 +626,22 @@ MisesMat :: give1dStressStiffMtrx(MatResponseMode mode,
     }
 
     if ( tempKappa <= kappa ) { // elastic loading - elastic stiffness plays the role of tangent stiffness
-        return elastic * (1 - omega);
+        return elastic * ( 1 - omega );
     }
 
     // === plastic loading ===
     const FloatArray &stressVector = status->giveTempEffectiveStress();
     double stress = stressVector.at(1);
-    return {( 1 - omega ) * E * H / ( E + H ) - computeDamageParamPrime(tempKappa) * E / ( E + H ) * stress * signum(stress)};
+    return {
+               ( 1 - omega ) * E * computeYieldStressPrime(kappa) / ( E + computeYieldStressPrime(kappa) ) - computeDamageParamPrime(tempKappa) * E / ( E + computeYieldStressPrime(kappa) ) * stress * signum(stress)
+    };
 }
 
 #ifdef __OOFEG
 #endif
 
 int
-MisesMat :: giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType type, TimeStep *tStep)
+MisesMat::giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType type, TimeStep *tStep)
 {
     MisesMatStatus *status = static_cast< MisesMatStatus * >( this->giveStatus(gp) );
     if ( type == IST_PlasticStrainTensor ) {
@@ -571,13 +660,13 @@ MisesMat :: giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType ty
         answer.at(1) = this->give('s', gp, tStep);
         return 1;
     } else {
-        return StructuralMaterial :: giveIPValue(answer, gp, type, tStep);
+        return StructuralMaterial::giveIPValue(answer, gp, type, tStep);
     }
 }
 
 //=============================================================================
 
-MisesMatStatus :: MisesMatStatus(GaussPoint *g) :
+MisesMatStatus::MisesMatStatus(GaussPoint *g) :
     StructuralMaterialStatus(g), plasticStrain(6), tempPlasticStrain(), trialStressD()
 {
     stressVector.resize(6);
@@ -588,9 +677,9 @@ MisesMatStatus :: MisesMatStatus(GaussPoint *g) :
 
 
 void
-MisesMatStatus :: printOutputAt(FILE *file, TimeStep *tStep) const
+MisesMatStatus::printOutputAt(FILE *file, TimeStep *tStep) const
 {
-    StructuralMaterialStatus :: printOutputAt(file, tStep);
+    StructuralMaterialStatus::printOutputAt(file, tStep);
 
     fprintf(file, "              plastic  ");
     for ( auto &val : this->plasticStrain ) {
@@ -612,9 +701,9 @@ MisesMatStatus :: printOutputAt(FILE *file, TimeStep *tStep) const
 
 
 // initializes temporary variables based on their values at the previous equlibrium state
-void MisesMatStatus :: initTempStatus()
+void MisesMatStatus::initTempStatus()
 {
-    StructuralMaterialStatus :: initTempStatus();
+    StructuralMaterialStatus::initTempStatus();
 
     tempDamage = damage;
     tempPlasticStrain = plasticStrain;
@@ -625,9 +714,9 @@ void MisesMatStatus :: initTempStatus()
 
 // updates internal variables when equilibrium is reached
 void
-MisesMatStatus :: updateYourself(TimeStep *tStep)
+MisesMatStatus::updateYourself(TimeStep *tStep)
 {
-    StructuralMaterialStatus :: updateYourself(tStep);
+    StructuralMaterialStatus::updateYourself(tStep);
 
     plasticStrain = tempPlasticStrain;
     kappa = tempKappa;
@@ -637,18 +726,18 @@ MisesMatStatus :: updateYourself(TimeStep *tStep)
 
 
 double
-MisesMat :: give(int aProperty, GaussPoint *gp, TimeStep *tStep) const
+MisesMat::give(int aProperty, GaussPoint *gp, TimeStep *tStep) const
 {
     if ( aProperty == 's' ) {
         ///FIXME: const cast workaround, until all methods have been properly marked const properly:
-        
-        return sig0.eval( { { "te", giveTemperature(gp, tStep) }, { "t", tStep->giveIntrinsicTime() } }, this->giveDomain(), gp, giveTemperature(gp, tStep) );
+
+        return sig0.eval({ { "te", giveTemperature(gp, tStep) }, { "t", tStep->giveIntrinsicTime() } }, this->giveDomain(), gp, giveTemperature(gp, tStep) );
     }
 
-    return Material :: give(aProperty, gp);
+    return Material::give(aProperty, gp);
 }
 
-double MisesMat :: giveTemperature(GaussPoint *gp, TimeStep *tStep) const
+double MisesMat::giveTemperature(GaussPoint *gp, TimeStep *tStep) const
 {
     FieldManager *fm = this->domain->giveEngngModel()->giveContext()->giveFieldManager();
     FieldPtr tf;
@@ -656,7 +745,7 @@ double MisesMat :: giveTemperature(GaussPoint *gp, TimeStep *tStep) const
     if ( ( tf = fm->giveField(FT_Temperature) ) ) {
         // temperature field registered
         FloatArray gcoords, answer;
-        static_cast< StructuralElement * >( gp->giveElement() )->computeGlobalCoordinates( gcoords, gp->giveNaturalCoordinates() );
+        static_cast< StructuralElement * >( gp->giveElement() )->computeGlobalCoordinates(gcoords, gp->giveNaturalCoordinates() );
         if ( ( err = tf->evaluateAt(answer, gcoords, VM_Total, tStep) ) ) {
             OOFEM_ERROR("tf->evaluateAt failed, element %d, error code %d", gp->giveElement()->giveNumber(), err);
         }
@@ -667,9 +756,9 @@ double MisesMat :: giveTemperature(GaussPoint *gp, TimeStep *tStep) const
 
 
 void
-MisesMatStatus :: saveContext(DataStream &stream, ContextMode mode)
+MisesMatStatus::saveContext(DataStream &stream, ContextMode mode)
 {
-    StructuralMaterialStatus :: saveContext(stream, mode);
+    StructuralMaterialStatus::saveContext(stream, mode);
 
     contextIOResultType iores;
     if ( ( iores = plasticStrain.storeYourself(stream) ) != CIO_OK ) {
@@ -687,9 +776,9 @@ MisesMatStatus :: saveContext(DataStream &stream, ContextMode mode)
 
 
 void
-MisesMatStatus :: restoreContext(DataStream &stream, ContextMode mode)
+MisesMatStatus::restoreContext(DataStream &stream, ContextMode mode)
 {
-    StructuralMaterialStatus :: restoreContext(stream, mode);
+    StructuralMaterialStatus::restoreContext(stream, mode);
 
     contextIOResultType iores;
     if ( ( iores = plasticStrain.restoreYourself(stream) ) != CIO_OK ) {
diff --git a/src/sm/Materials/misesmat.h b/src/sm/Materials/misesmat.h
index 4874f37b1..905639c3c 100644
--- a/src/sm/Materials/misesmat.h
+++ b/src/sm/Materials/misesmat.h
@@ -48,6 +48,9 @@
 #define _IFT_MisesMat_Name "misesmat"
 #define _IFT_MisesMat_sig0 "sig0"
 #define _IFT_MisesMat_h "h"
+#define _IFT_MisesMat_htype "htype"
+#define _IFT_MisesMat_h_eps "h_eps"
+#define _IFT_MisesMat_h_function_eps "h(eps)"
 #define _IFT_MisesMat_omega_crit "omega_crit"
 #define _IFT_MisesMat_a "a"
 #define _IFT_MisesMat_yieldTol "yieldtol"
@@ -88,6 +91,12 @@ class MisesMat : public StructuralMaterial
     /// Initial (uniaxial) yield stress.
     ScalarFunction sig0;
 
+    /// type of hardening function
+    int hType;
+
+    /// user-defined hardening (yield stress - kappa)
+    FloatArray h_eps, h_function_eps;
+
     /// critical(maximal) damage.
     double omega_crit = 0.;
     /// exponent in damage function.
@@ -100,8 +109,9 @@ class MisesMat : public StructuralMaterial
     MisesMat(int n, Domain *d);
 
     void performPlasticityReturn(const FloatArray &totalStrain, GaussPoint *gp, TimeStep *tStep) const;
-    void performPlasticityReturn_PlaneStress(const FloatArrayF<3> &totalStrain, GaussPoint *gp, TimeStep *tStep) const;
+    void performPlasticityReturn_PlaneStress(const FloatArrayF< 3 > &totalStrain, GaussPoint *gp, TimeStep *tStep) const;
 
+    double checkYieldStress(double &dKappa, double kappa, GaussPoint *gp, TimeStep *tStep) const;
     double computeYieldStress(double kappa, GaussPoint *gp, TimeStep *tStep) const;
     double computeYieldStressPrime(double kappa) const;
 
@@ -119,17 +129,17 @@ class MisesMat : public StructuralMaterial
 
     MaterialStatus *CreateStatus(GaussPoint *gp) const override;
 
-    FloatMatrixF<6,6> give3dMaterialStiffnessMatrix(MatResponseMode mode, GaussPoint *gp, TimeStep *tStep) const override;
+    FloatMatrixF< 6, 6 >give3dMaterialStiffnessMatrix(MatResponseMode mode, GaussPoint *gp, TimeStep *tStep) const override;
 
-    FloatMatrixF<3,3> givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, TimeStep *tStep) const override;
+    FloatMatrixF< 3, 3 >givePlaneStressStiffMtrx(MatResponseMode mmode, GaussPoint *gp, TimeStep *tStep) const override;
 
-    FloatMatrixF<1,1> give1dStressStiffMtrx(MatResponseMode mode, GaussPoint *gp, TimeStep *tStep) const override;
+    FloatMatrixF< 1, 1 >give1dStressStiffMtrx(MatResponseMode mode, GaussPoint *gp, TimeStep *tStep) const override;
 
-    FloatArrayF<6> giveRealStressVector_3d(const FloatArrayF<6> &strain, GaussPoint *gp, TimeStep *tStep) const override;
+    FloatArrayF< 6 >giveRealStressVector_3d(const FloatArrayF< 6 > &strain, GaussPoint *gp, TimeStep *tStep) const override;
 
-    FloatArrayF<3> giveRealStressVector_PlaneStress(const FloatArrayF<3> &totalStrain, GaussPoint *gp,TimeStep *tStep) const override;
+    FloatArrayF< 3 >giveRealStressVector_PlaneStress(const FloatArrayF< 3 > &totalStrain, GaussPoint *gp, TimeStep *tStep) const override;
 
-    FloatArrayF<1> giveRealStressVector_1d(const FloatArrayF<1> &reducedE, GaussPoint *gp, TimeStep *tStep) const override;
+    FloatArrayF< 1 >giveRealStressVector_1d(const FloatArrayF< 1 > &reducedE, GaussPoint *gp, TimeStep *tStep) const override;
 
     double give(int aProperty, GaussPoint *gp, TimeStep *tStep) const;
     double giveTemperature(GaussPoint *gp, TimeStep *tStep) const;
diff --git a/tests/sm/Mises02.in b/tests/sm/Mises02.in
new file mode 100644
index 000000000..07ad1f880
--- /dev/null
+++ b/tests/sm/Mises02.in
@@ -0,0 +1,29 @@
+Mises02.out
+Test of Mises plasticity model with multilinear hardening/softening
+StaticStructural nsteps 10 rtolf 1e-4 maxiter 20 nmodules 1
+errorcheck
+#vtkxml tstep_all domain_all primvars 1 1
+domain 1dtruss
+OutputManager tstep_all dofman_all element_all
+ndofman 2 nelem 1 ncrosssect 1 nmat 1 nbc 2 nltf 2 nic 0 nset 3
+node 1 coords 3 0.0 0.0 0.0
+node 2 coords 3 0.5 0.0 0.0
+truss1d 1 nodes 2 1 2
+SimpleCS 1 thick 1.0 width 10.0 material 1 set 1
+MisesMat 1 d 1.0 tAlpha 0.0 E 1. n 0.2 htype 1 h_eps 3 0. 3. 25. h(eps) 3 1. 2. 1.
+BoundaryCondition 1 loadTimeFunction 1 dofs 1 1 values 1 0.0 set 2
+BoundaryCondition 2 loadTimeFunction 2 dofs 1 1 values 1 1.0 set 3
+ConstantFunction 1 f(t) 1.0
+PiecewiseLinFunction 2 t 2 0. 11.0 f(t) 2 0.0 12.0
+Set 1 elementranges {1}
+Set 2 nodes 1 1
+Set 3 nodes 1 2
+###
+### Used for Extractor
+
+#%BEGIN_CHECK% tolerance 1.e-4
+#ELEMENT tStep 3 number 1 gp 1 keyword 4 component 1  value 6.5455e+00
+#ELEMENT tStep 3 number 1 gp 1 keyword 1 component 1  value 1.9264e+00
+#ELEMENT tStep 20 number 1 gp 1 keyword 4 component 1  value 2.1818e+01
+#ELEMENT tStep 20 number 1 gp 1 keyword 1 component 1  value 1.1991e+00
+#%END_CHECK%

From f7768ddba8858f8cca3fc80aaaf83f4307499a86 Mon Sep 17 00:00:00 2001
From: githubgrasp <peter.grassl@glasgow.ac.uk>
Date: Tue, 10 Nov 2020 18:25:49 +0000
Subject: [PATCH 3/4] Fix typos in matlibmanual

---
 doc/matlibmanual/matlibmanual.tex | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/doc/matlibmanual/matlibmanual.tex b/doc/matlibmanual/matlibmanual.tex
index 0e562546d..88260ce49 100644
--- a/doc/matlibmanual/matlibmanual.tex
+++ b/doc/matlibmanual/matlibmanual.tex
@@ -395,7 +395,7 @@ \subsubsection{Hyperelastic material - Blatz-Ko}
 \begin{equation}\label{freeEnergyBlatzKo}
 \rho_0 \psi = \frac{\mu}{2}\left(\frac{I_2}{I_3} + 2\sqrt{I_3}-5 \right)
 \end{equation}
-where $\mu$ is initial shear modulus, $I_2$ and $I_3$ are the second and third invariants of the Cauchy-Green tensor $\bm{C}$.
+where $\mu$ is initial shear modulus, $I_2$ and $I_3$ are the second and third invariants of the Cauchy-Green tensor $\mbf{C}$.
 
 The model description and parameters are summarized in Tab.~\ref{BlatzKo_table}.
 \begin{table}[!htb]
@@ -409,7 +409,7 @@ \subsubsection{Hyperelastic material - Blatz-Ko}
 		Parameters &- \param{} material number\\
 		&- \param{d} material density\\
 		&- \param{mu} shear modulus\\
-                \nu is fixed to 0.25\\
+                $\nu$ is fixed to 0.25\\
 		\hline
 	\end{mmt}
 	\caption{Blatz-Ko material - summary.}

From 0faed5fb520f3ca4808a41f8c7a2f67f9abf3c7e Mon Sep 17 00:00:00 2001
From: vit-smilauer <vit.smilauer@fsv.cvut.cz>
Date: Fri, 30 Oct 2020 13:34:15 +0100
Subject: [PATCH 4/4] Added qbrick1mt transport element.

---
 doc/elementlibmanual/elementlibmanual.tex |  4 ++++
 src/oofemlib/materialmode.h               |  6 +++---
 src/tm/Elements/qbrick1_ht.C              |  6 ++++++
 src/tm/Elements/qbrick1_ht.h              | 15 +++++++++++++++
 4 files changed, 28 insertions(+), 3 deletions(-)

diff --git a/doc/elementlibmanual/elementlibmanual.tex b/doc/elementlibmanual/elementlibmanual.tex
index 37eec8d8d..5fe4b7540 100644
--- a/doc/elementlibmanual/elementlibmanual.tex
+++ b/doc/elementlibmanual/elementlibmanual.tex
@@ -1807,6 +1807,10 @@ \subsubsection{QBrick1ht - quadratic hexahedral 3D element}\label{QBrick1ht_elem
 \elementDescription{Status}{}
 \end{elementsummary}
 
+\subsubsection{QBrick1mt - quadratic hexahedral 3D element}
+The same element as QBrick1ht for mass transfer problems, see \ref{QBrick1ht_element}. 
+Linear approximation of mass concentration.
+
 \subsubsection{QBrick1hmt - quadratic hexahedral 3D element}
 The same element as QBrick1ht for
 heat and mass (one constituent) transfer problems. 
diff --git a/src/oofemlib/materialmode.h b/src/oofemlib/materialmode.h
index 2c719c107..992b38e3e 100644
--- a/src/oofemlib/materialmode.h
+++ b/src/oofemlib/materialmode.h
@@ -66,11 +66,11 @@ namespace oofem {
     ENUM_ITEM(_2dInterface) \
     ENUM_ITEM(_1dInterface) \
   \
-    ENUM_ITEM(_1dHeat) /* 1d heat */ \
+    ENUM_ITEM(_1dHeat) /* 1d heat or 1d mass*/ \
     ENUM_ITEM(_1dHeMo) /* 1d heat and mass (one component) transfer */ \
-    ENUM_ITEM(_2dHeat) /* 2d heat */ \
+    ENUM_ITEM(_2dHeat) /* 2d heat or 2d mass */ \
     ENUM_ITEM(_2dHeMo) /* 2d heat and mass (one component) transfer */ \
-    ENUM_ITEM(_3dHeat) /* 3d heat */ \
+    ENUM_ITEM(_3dHeat) /* 3d heat or 3d mass */ \
     ENUM_ITEM(_3dHeMo) /* 3d heat and mass (one component) transfer */ \
   \
     ENUM_ITEM(_2dFlow) \
diff --git a/src/tm/Elements/qbrick1_ht.C b/src/tm/Elements/qbrick1_ht.C
index 8b3cd6e06..a2f066d3f 100644
--- a/src/tm/Elements/qbrick1_ht.C
+++ b/src/tm/Elements/qbrick1_ht.C
@@ -49,6 +49,7 @@
 namespace oofem {
 REGISTER_Element(QBrick1_ht);
 REGISTER_Element(QBrick1_hmt);
+REGISTER_Element(QBrick1_mt);
 
 FEI3dHexaQuad QBrick1_ht :: interpolation;
 
@@ -63,6 +64,11 @@ QBrick1_hmt :: QBrick1_hmt(int n, Domain *aDomain) : QBrick1_ht(n, aDomain)
     emode = HeatMass1TransferEM;
 }
 
+QBrick1_mt :: QBrick1_mt(int n, Domain *aDomain) : QBrick1_ht(n, aDomain)
+{
+    emode = Mass1TransferEM;
+}
+
 
 FEInterpolation *
 QBrick1_ht :: giveInterpolation() const { return & interpolation; }
diff --git a/src/tm/Elements/qbrick1_ht.h b/src/tm/Elements/qbrick1_ht.h
index fb0244d6e..d97d43ed6 100644
--- a/src/tm/Elements/qbrick1_ht.h
+++ b/src/tm/Elements/qbrick1_ht.h
@@ -43,6 +43,8 @@
 
 #define _IFT_QBrick1_ht_Name "qbrick1ht"
 #define _IFT_QBrick1_hmt_Name "qbrick1hmt"
+#define _IFT_QBrick1_mt_Name "qbrick1mt"
+
 
 namespace oofem {
 class FEI3dHexaQuad;
@@ -93,5 +95,18 @@ class QBrick1_hmt : public QBrick1_ht
     const char *giveInputRecordName() const override { return _IFT_QBrick1_hmt_Name; }
     const char *giveClassName() const override { return "QBrick1_hmt"; }
 };
+
+/**
+ * Class for mass transfer.
+ */
+class QBrick1_mt : public QBrick1_ht
+{
+public:
+    QBrick1_mt(int n, Domain * d);
+
+    const char *giveInputRecordName() const override { return _IFT_QBrick1_mt_Name; }
+    const char *giveClassName() const override { return "QBrick1_mt"; }
+    MaterialMode giveMaterialMode() override { return _3dHeat; }
+};
 } // end namespace oofem
 #endif // qbrick1_ht_h
