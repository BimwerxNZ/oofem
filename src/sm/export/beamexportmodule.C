/*
*
*                 #####    #####   ######  ######  ###   ###
*               ##   ##  ##   ##  ##      ##      ## ### ##
*              ##   ##  ##   ##  ####    ####    ##  #  ##
*             ##   ##  ##   ##  ##      ##      ##     ##
*            ##   ##  ##   ##  ##      ##      ##     ##
*            #####    #####   ##      ######  ##     ##
*
*
*             OOFEM : Object Oriented Finite Element Code
*
*               Copyright (C) 1993 - 2013   Borek Patzak
*
*
*
*       Czech Technical University, Faculty of Civil Engineering,
*   Department of Structural Mechanics, 166 29 Prague, Czech Republic
*
*  This library is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 2.1 of the License, or (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License along with this library; if not, write to the Free Software
*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "beamexportmodule.h"
#include "timestep.h"
#include "element.h"
#include "../sm/Elements/structuralelement.h"
#include "../sm/Elements/Beams/beam3d.h"
#include "gausspoint.h"
#include "engngm.h"
#include "material.h"
#include "classfactory.h"
#include "generalboundarycondition.h"
#include "constantedgeload.h"
#include "fei3dlinelin.h"

namespace oofem {
	REGISTER_ExportModule(BeamExportModule)

		BeamExportModule::BeamExportModule(int n, EngngModel *e) : ExportModule(n, e) { }

	BeamExportModule :: ~BeamExportModule() { }

	IRResultType
		BeamExportModule::initializeFrom(InputRecord *ir)
	{
		//IRResultType result;                 // Required by IR_GIVE_FIELD macro
		return ExportModule::initializeFrom(ir);
	}

	void
		addComponents(FloatArray &dst, FloatArray &src, double pos, double len, bool momentOnly = false)
	{
		if (!momentOnly) {
			// axial force. linear interpolation
			dst.at(1) += src.at(1) * (len / 2 - pos);

			// shear forces. linear interpolation
			dst.at(3) += src.at(3) * (len / 2 - pos);
			dst.at(2) += src.at(2) * (len / 2 - pos);
		}

		// only these two parabolic. linear interpolation should be enough for the other directions
		dst.at(5) += src.at(3) * (pos) / 2 * (len - pos);
		dst.at(6) -= src.at(2) * (pos) / 2 * (len - pos);
	}

	int checkValidType(const char* name)
	{
		return (strcmp(name, "Beam3d") == 0) || (strcmp(name, "Beam2d") == 0) || (strcmp(name, "beam3d") == 0) || (strcmp(name, "beam2d") == 0);
	}

	void
		BeamExportModule::doOutput(TimeStep *tStep, bool forcedOutput)
	{
		if (!(testTimeStepOutput(tStep) || forcedOutput)) {
			return;
		}

		std::vector< int >beamIDs;
		std::map< int, std::map< double, FloatArray > >BeamForces;
		std::map< int, std::map< double, FloatArray > >BeamDisplacements;
		std::map<int, FloatArray >BeamLoads;
		IntArray temp;
		// loop through the beam elements
		Domain *d = emodel->giveDomain(1);
		for (auto &elem : d->giveElements()) {
			if (checkValidType(elem->giveClassName())) {   // check if elem is beam (LIbeam?)

				int elNum;
				elNum = elem->giveNumber();
				//elNum = elem->giveLabel();

				// store IDs of known beams
				beamIDs.push_back( elNum );
				//beamIDs.push_back(elNum);

				StructuralElement *SElem;

				SElem = static_cast<StructuralElement *>(elem.get());

				double ksi, l = elem->computeLength();
				FloatArray Fl, loadEndForces;

				SElem->giveInternalForcesVector(Fl, tStep);

				// add exact end forces due to nonnodal loading
				SElem->computeForceLoadVector(loadEndForces, tStep, VM_Total);
				if (loadEndForces.giveSize()) {
					Fl.subtract(loadEndForces);
				}

				std::map< double, FloatArray >ForceDict;
				FloatArray I, E, Diff, dI, dE;

				I.resize(6);

				temp.resize(6);
				temp.at(1) = 1;
				temp.at(2) = 2;
				temp.at(3) = 3;
				temp.at(4) = 4;
				temp.at(5) = 5;
				temp.at(6) = 6;
				I.beSubArrayOf(Fl, temp);
				I *= -1; // invert sign of I end

				E.resize(6);
				for (int i = 1; i < 7; i++) {
					temp.at(i) = temp.at(i) + 6;
				}
				E.beSubArrayOf(Fl, temp);

				Diff.beDifferenceOf(E, I);

				FloatArray FinalLoads;
				FinalLoads.resize(6);
				FinalLoads.zero();

				FloatMatrix T;
				elem->computeGtoLRotationMatrix(T);
				T.resizeWithData(6, 6);

				temp.resize(6);
				temp.at(1) = 1;
				temp.at(2) = 2;
				temp.at(3) = 3;
				temp.at(4) = 4;
				temp.at(5) = 5;
				temp.at(6) = 6;

				IntArray *loads = elem->giveBoundaryLoadArray();
				for (auto &loadNum : *loads)
				{
					GeneralBoundaryCondition *bc = d->giveBc(loadNum);
					if (strcmp(bc->giveClassName(), "ConstantEdgeLoad") == 0) {
						ConstantEdgeLoad *CLoad = static_cast<ConstantEdgeLoad *>(bc);
						FloatArray compArr;
						const FloatArray coords;

						// CLoad->computeValues(compArr, tStep, NULL, temp, VM_Total);
						CLoad->computeValues(compArr, tStep, coords, temp, VM_Total);

						// transform to local coordinates
						compArr.rotatedWith(T, 'n');
						FinalLoads.add(compArr);
					}
				}

				addComponents(I, FinalLoads, 0.0, l, true);
				ForceDict[0.0] = I;

				for (GaussPoint *gp : *elem->giveDefaultIntegrationRulePtr()) {
					//double dV = elem->computeVolumeAround(gp);
					FloatArray ipState;
					double pos;

					ksi = 0.5 + 0.5 * gp->giveNaturalCoordinate(1);
					pos = ksi*l;

					// can't use this until beam is fixed?
					// elem->giveGlobalIPValue(ipState, gp, (InternalStateType)1, tStep); // IST_StressTensor
					ipState.zero();
					ipState.beScaled(ksi, Diff);
					ipState.add(I);

					addComponents(ipState, FinalLoads, pos, l, true);

					ForceDict[pos] = ipState;
				}

				addComponents(E, FinalLoads, l, l, true);
				ForceDict[l] = E;

				BeamForces [ elem->giveNumber() ] = ForceDict;
				//BeamForces[elem->giveLabel()] = ForceDict;

				//std::pair <double, double> loadPair;
				//loadPair.first = FinalLoads.at(2);
				//loadPair.second = FinalLoads.at(3);

				// save loads
				BeamLoads[elem->giveNumber()] = FinalLoads;

				//elem->giveBodyLoadArray
			}
		}

		//std::vector< std::unique_ptr< GeneralBoundaryCondition > > BCs = d->giveBcs();

		// tamper with stuff only if sets are defined.
		if (d->giveNumberOfSets()) {
			temp.resize(6);
			temp.at(1) = 1;
			temp.at(2) = 2;
			temp.at(3) = 3;
			temp.at(4) = 4;
			temp.at(5) = 5;
			temp.at(6) = 6;
			// loop through the loads
			for (auto &bc : d->giveBcs()) {
				// int bType = bc->giveBCValType(); // UNUSED: ConstantEdgeLoad is never == 2, they're all == 0 == unknown
				//if (bc->giveBCValType() == ForceLoadBVT) {
				if (strcmp(bc->giveClassName(), "ConstantEdgeLoad") == 0) {
					ConstantEdgeLoad *CLoad = static_cast<ConstantEdgeLoad *>(bc.get());

					// is it in a set?
					int nSet = CLoad->giveSetNumber();
					if (nSet) {
						Set *mySet = d->giveSet(nSet);
						// contains any of our beams?
						const IntArray &EdgeList = mySet->giveEdgeList();
						int numEdges = EdgeList.giveSize();

						int c = 1;
						while (c <= numEdges) {
							FloatArray compArr, tempArr;
							FloatMatrix T;
							int elNum = EdgeList.at(c);
							c += 2; // increment counter in interleaved array

							Element* ele = d->giveElement(elNum);
							if (!checkValidType(ele->giveClassName())) continue;

							const FloatArray coords;

							// CLoad->computeValues(compArr, tStep, NULL, temp, VM_Total);
							CLoad->computeValues(compArr, tStep, coords, temp, VM_Total);
							//d->giveElement(elNum)->computeBoundaryEdgeLoadVector(compArr, CLoad, edgeNum, ExternalForcesVector, VM_Total, tStep); // always vm_total???

							// transform to local coordinates
							d->giveElement(elNum)->computeGtoLRotationMatrix(T);
							T.resizeWithData(6, 6);
							compArr.rotatedWith(T, 'n');

							// add loads to our map
							BeamLoads[elNum] += compArr;
							//BeamLoads[elNum].first += compArr.at(2);
							//BeamLoads[elNum].second += compArr.at(3);

							// compute contribution to internal forces
							std::map< double, FloatArray >Dst = BeamForces[elNum];
							for (auto &PointVals : Dst) {
								const double &pos = PointVals.first;
								FloatArray Vals = PointVals.second;

								// tamper with values?
								addComponents(Vals, compArr, pos, d->giveElement(elNum)->computeLength());

								// update in point-forces map
								PointVals.second = Vals;
							}
							// update in beam-forces map
							BeamForces[elNum] = Dst;
						}
					}
				}
				//}
			}
		}

		for (auto beamPair : BeamForces)
		{
			int elNum = beamPair.first;
			Element *elem = d->giveElement(elNum);
			FloatArray rl, dI, dE; // used to store element end displacements
			FloatArray dNI, dNE; // used to store nodal displacements - may be different from the previous because of releases.
			FloatArray ddN; // used to store the difference between the ends.
			std::map< double, FloatArray >DispDict;
			double l = elem->computeLength();
			double l_2 = l*l;
			double ksi;
			//FloatMatrix shapeFunctions(2, 12);
			bool calc = false;
			//double phiy, phiz;

			elem->computeVectorOf(VM_Total, tStep, rl);
			temp.resize(6);
			temp.at(1) = 1;
			temp.at(2) = 2;
			temp.at(3) = 3;
			temp.at(4) = 4;
			temp.at(5) = 5;
			temp.at(6) = 6;

			FloatMatrix T;
			elem->computeGtoLRotationMatrix(T);
			T.resizeWithData(6, 6);

			dI.beSubArrayOf(rl, temp);
			//dI.rotatedWith(T, 'n');  // no need?

			DofManager *dofMan = elem->giveDofManager(1);
			dofMan->giveCompleteUnknownVector(dNI, VM_Total, tStep);
			FloatMatrix N;
			if (dofMan->computeL2GTransformation(N, NULL))
			{
				dNI.rotatedWith(N, 'n'); // rotate to global c.s.
			}
			dNI.rotatedWith(T, 'n');	// rotate to element c.s.

			dofMan = elem->giveDofManager(2);
			dofMan->giveCompleteUnknownVector(dNE, VM_Total, tStep);
			if (dofMan->computeL2GTransformation(N, NULL))
			{
				dNE.rotatedWith(N, 'n'); // rotate to global c.s.
			}
			dNE.rotatedWith(T, 'n');	// rotate to element c.s.

			ddN = dNE - dNI;

			// increment id array
			for (int i = 1; i <= 6; i++) temp.at(i) += 6;
			dE.beSubArrayOf(rl, temp);
			//dE.rotatedWith(T, 'n');

			//ddN = dE - dI;

			DispDict[0.0] = dI -dNI;

			CrossSection *Sect = elem->giveCrossSection();
			StructuralCrossSection *SCSect = static_cast<StructuralCrossSection *>(Sect);
			FloatMatrix MatStiffness;

			double EJyy, EJzz, EA, GJ;
			double ay, by, cy, dy, ey;
			double anx, bnx, cnx;
			double az, bz, cz, dz, ez;

			for (GaussPoint *gp : *elem->giveDefaultIntegrationRulePtr()) {
				FloatArray ipState;
				double pos, pos_2, pos_3, pos_4;

				ksi = 0.5 + 0.5 * gp->giveNaturalCoordinate(1);
				pos = ksi*l;

				pos_2 = pos*pos;
				pos_3 = pos_2*pos;
				pos_4 = pos_2*pos_2;

				// calculate this stuff on the first pass. Section are supposed prismatic (constant section)
				if (!calc){
					SCSect->give3dBeamStiffMtrx(MatStiffness, ElasticStiffness, gp, tStep);

					EA = MatStiffness.at(1, 1);
					GJ = MatStiffness.at(4, 4);
					EJzz = MatStiffness.at(6, 6);
					EJyy = MatStiffness.at(5, 5);

					double vy_0, vy_l, vz_0, vz_l;
					double phiy_0, phiy_l, phiz_0, phiz_l;
					double By, Ay, Bz, Az;
					double dx_0, dx_l;

					//std::map<double, FloatArray> &td = BeamDisplacements[elNum];
					FloatArray &bl = BeamLoads[elNum];
					FloatArray *disps = &dI;
					vy_0 = disps->at(2);
					vz_0 = disps->at(3);
					phiy_0 = disps->at(5);
					phiz_0 = disps->at(6);
					dx_0 = disps->at(1);

					disps = &dE;
					vy_l = disps->at(2);
					vz_l = disps->at(3);
					phiy_l = disps->at(5);
					phiz_l = disps->at(6);
					dx_l = disps->at(1);

					ey = vy_0;
					dy = phiz_0;
					ay = bl.at(2) / 24 / EJzz;

					Ay = (vy_l - vy_0) / l_2 - ay*l_2 - dy / l;
					By = (phiz_l - phiz_0) / l - ay*l_2 * 4;

					by = (By - 2 * Ay) / l;
					cy = 3 * Ay - By;


					ez = vz_0;
					dz = -phiy_0; // inverted signs for angles
					az = bl.at(3) / 24 / EJyy;

					Az = (vz_l - vz_0) / l_2 - az*l_2 - dz / l;
					Bz = (-phiy_l + phiy_0) / l - az*l_2 * 4; // inverted signs for angles

					bz = (Bz - 2 * Az) / l;
					cz = 3 * Az - Bz;


					cnx = dx_0;
					anx = bl.at(1) / 2 / EA;
					bnx = (dx_l - dx_0) / l - anx*l;

					calc = true;
				}

				FloatArray disps(6);
				disps.at(1) = anx*pos_2 + bnx*pos + cnx;
				disps.at(2) = ay*pos_4 + by*pos_3 + cy*pos_2 + dy*pos + ey;
				disps.at(3) = az*pos_4 + bz*pos_3 + cz*pos_2 + dz*pos + ez;

				disps -= (dI+ddN*ksi);

				DispDict[pos] = disps;

				//ipDisp.beProductOf(shapeFunctions, rl);
			}

			DispDict[l] = dE - dNE;

			// save the displacements
			BeamDisplacements[elem->giveNumber()] = DispDict;
			//BeamDisplacements[elem->giveLabel()] = DispDict;

		}

		//for (auto &set : d->giveSets()) {
		//	IntArray &ElEdges = set->giveEdgeList();
		//}

		//	d->giveSets or d->giveLoad ?

		double curTime = tStep->giveTargetTime();
		std::map<int, std::map<double, FloatArray>>::iterator BForces_it = BeamForces.begin();
		std::map<int, std::map<double, FloatArray>>::iterator BDisps_it = BeamDisplacements.begin();
		for (;
			BForces_it != BeamForces.end();
			++BForces_it, ++BDisps_it)
		{
			std::map< double, FloatArray > &BForces = BForces_it->second;
			std::map< double, FloatArray > &BDisps = BDisps_it->second;
			Element* elem = d->giveElement(BForces_it->first);
			int ID = elem->giveLabel();

			std::map<double, FloatArray >::iterator forces_it = BForces.begin();
			std::map<double, FloatArray >::iterator disps_it = BDisps.begin();

			for (;
				forces_it != BForces.end();
				++forces_it, ++disps_it)
			{
				double pos = forces_it->first;
				FloatArray forces = forces_it->second;
				FloatArray disps = disps_it->second;
				fprintf(this->stream, "%10.3e;%d;%10.3e;", curTime, ID, pos);

				for (auto &val : forces) {
					fprintf(this->stream, "%10.3e;", val);
				}
				for (auto &val : disps) {
					fprintf(this->stream, "%10.3e;", val);
				}
				fprintf(this->stream, "\n");
			}

		}

		//for (auto &bForces : BeamForces) {
		//	std::map< double, FloatArray >pForces = bForces.second;
		//	int ID = bForces.first;
		//	for (auto &vals : pForces) {
		//		double pos = vals.first;
		//		FloatArray forces = vals.second;
		//		fprintf(this->stream, "%10.3e;%d;%10.3e;", curTime, ID, pos);
		//		for (auto &val : forces) {
		//			fprintf(this->stream, "%10.3e;", val);
		//		}
		//		fprintf(this->stream, "\n");
		//	}
		//}

		// write file in the format:
		// elementNumber distanceFromIend N_x T_z T_y M_x M_y M_z
		// if 3 Gauss points are used, there would be 5 lines per beam (at distances 0, 0.1127*L, 0.5*L, 0.8873*L, L), ->>> to check

		//fprintf(this->stream, "%d ", avgState.giveSize());
		//for ( auto s: avgState ) {
		//    fprintf(this->stream, "%e ", s);
		//}
		//fprintf(this->stream, "    ");

		fflush(this->stream);
	}


	void
		BeamExportModule::initialize()
	{
		std::string fileName = emodel->giveOutputBaseFileName() + ".bem";
		if ((this->stream = fopen(fileName.c_str(), "w")) == NULL) {
			OOFEM_ERROR("failed to open file %s", fileName.c_str());
		}
		// ";" as separator
		fprintf(this->stream, "#Time;BeamNo;DistanceFromI;N_x;T_y;T_z;M_x;M_y;M_z;dx;dy;dz;rx;ry;rz;");
		//for ( int var: this->ists ) {
		//    fprintf(this->stream, "%s    ", __InternalStateTypeToString( ( InternalStateType ) var) );
		//}
		fprintf(this->stream, "\n");
		fflush(this->stream);
	}

	void
		BeamExportModule::terminate()
	{
		fclose(this->stream);
	}
} // end namespace oofem